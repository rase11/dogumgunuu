<!DOCTYPE html>
<html lang="tr">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
    <title>Sana √ñzel Bir Oyun ‚Äî ƒ∞yile≈ütirilmi≈ü</title>
    <script src="https://cdn.jsdelivr.net/npm/phaser@3.55.2/dist/phaser.min.js"></script>
    <style>
        html,body { margin:0; padding:0; height:100%; background:#000; }
        body {
            font-family: "Arial Black", Arial, sans-serif;
            touch-action: none; /* mobile s√ºr√ºkleme engelle */
            -webkit-user-select:none;
            -ms-user-select:none;
            user-select:none;
        }
        #game-container { width:100vw; height:100vh; overflow:hidden; }
        #orientation-warning {
            position: fixed; inset:0; display:none;
            background:#222; color:#fff; z-index:9999;
            display:flex; flex-direction:column; justify-content:center; align-items:center;
            text-align:center;
        }
        #orientation-warning h1{ font-size:56px; margin:0 0 12px 0; }
        @media screen and (orientation:portrait) {
            #orientation-warning { display:flex; }
            #game-container { display:none; }
        }
    </style>
</head>
<body>
<div id="orientation-warning">
    <h1>üì±‚ÜîÔ∏è</h1>
    <h2>L√ºtfen Telefonu Yan √áevir</h2>
    <p>Oyun keyfi i√ßin ekranƒ± d√∂nd√ºr.</p>
</div>

<div id="game-container"></div>

<script>
(() => {
    const MAP_WIDTH = 4000;
    const GROUND_HEIGHT = 64;

    const config = {
        type: Phaser.AUTO,
        parent: 'game-container',
        scale: {
            mode: Phaser.Scale.RESIZE,
            width: '100%',
            height: '100%',
            autoCenter: Phaser.Scale.CENTER_BOTH
        },
        backgroundColor: '#87CEEB',
        physics: {
            default: 'arcade',
            arcade: {
                gravity: { y: 1300 },
                debug: false
            }
        },
        scene: { preload, create, update }
    };

    const game = new Phaser.Game(config);

    let player, princess, cursors, scoreText, hearts, music;
    let emitter, bgFar, bgMid, bgFront;
    let btnLeft, btnRight, btnJump;
    let isLeft = false, isRight = false, isJump = false;
    let platforms;

    function preload() {
        // audio + user assets (local)
        this.load.audio('theme', 'muzik.mp3');

        // phaser sample assets (clouds/platform/particles)
        this.load.image('sky', 'https://labs.phaser.io/assets/skies/sky4.png'); // geni≈ü g√∂ky√ºz√º
        this.load.image('clouds', 'https://labs.phaser.io/assets/skies/clouds.png');
        this.load.image('clouds2', 'https://labs.phaser.io/assets/skies/space3.png');

        this.load.image('ground', 'https://labs.phaser.io/assets/sprites/platform.png');
        this.load.image('sparkle', 'https://labs.phaser.io/assets/particles/blue.png');
        this.load.image('heart', 'https://labs.phaser.io/assets/sprites/heart.png');

        // user's sprites (local files)
        this.load.image('prens', 'prens.png');
        this.load.image('prenses', 'prenses.png');
        this.load.image('finalScene', 'final.png');
    }

    function create() {
        // FIRST TOUCH -> fullscreen + music start
        this.input.once('pointerdown', () => {
            if (this.scale.startFullscreen) this.scale.startFullscreen();
            if (!music || !music.isPlaying) music = this.sound.add('theme', { loop:true, volume:0.5 });
            if (music && !music.isPlaying) music.play();
        });

        // BACKGROUNDS - parallax katmanlarƒ±
        bgFar = this.add.tileSprite(0, 0, this.scale.width, this.scale.height, 'sky').setOrigin(0).setScrollFactor(0);
        bgMid = this.add.tileSprite(0, 0, this.scale.width, this.scale.height * 0.6, 'clouds2').setOrigin(0).setScrollFactor(0);
        bgFront = this.add.tileSprite(0, this.scale.height * 0.05, this.scale.width, this.scale.height * 0.25, 'clouds').setOrigin(0).setScrollFactor(0);

        // world bounds / camera
        this.cameras.main.setBounds(0, 0, MAP_WIDTH, this.scale.height);
        this.physics.world.setBounds(0, 0, MAP_WIDTH, this.scale.height);

        // STATIC PLATFORMS GROUP
        platforms = this.physics.add.staticGroup();

        // compute bottomY based on viewport
        const bottomY = this.scale.height - GROUND_HEIGHT/2;

        // create floors with sensible gaps and widths (d√ºzg√ºn hizalama)
        createFloor(this, platforms, 0, 900);
        createFloor(this, platforms, 1000, 1600);
        createFloor(this, platforms, 1700, 2300);
        createFloor(this, platforms, 2500, MAP_WIDTH);

        // small blocks
        createBlock(platforms, 450, bottomY - 90);
        createBlock(platforms, 650, bottomY - 190);
        createBlock(platforms, 1200, bottomY - 120);
        createBlock(platforms, 2100, bottomY - 110);

        // moving platforms (physics group)
        const moving = this.physics.add.group({ allowGravity:false, immovable:true });
        const mp1 = moving.create(900, bottomY - 120, 'ground').setDisplaySize(150, 32).refreshBody();
        setMovingData(mp1, 850, 950, 80);
        const mp2 = moving.create(2600, bottomY - 90, 'ground').setDisplaySize(140, 32).refreshBody();
        setMovingData(mp2, 2450, 2750, 120);

        // PARTICLES (emitter) - follow player and more stable
        const particles = this.add.particles('sparkle');
        emitter = particles.createEmitter({
            speed: { min: -40, max: 40 },
            scale: { start: 0.18, end: 0 },
            lifespan: 350,
            blendMode: 'ADD',
            quantity: 1,
            on: false
        });

        // PLAYER - place on first floor center
        const firstFloor = platforms.getChildren()[0];
        const startX = Phaser.Math.Clamp(firstFloor.x - (firstFloor.displayWidth/2) + 120, 80, MAP_WIDTH - 200);
        const startY = firstFloor.y - (GROUND_HEIGHT/2);

        player = this.physics.add.sprite(startX, startY, 'prens');
        player.setOrigin(0.5, 1);
        player.setDisplaySize(64, 96); // g√∂r√ºn√º≈ü i√ßin uygun √∂l√ßek
        // stabilize body size & offset to match sprite
        player.body.setSize(34, 82);
        player.body.setOffset((player.width - 34)/2, player.height - 82);
        player.setCollideWorldBounds(true);
        player.setBounce(0);
        player.setMaxVelocity(400, 1200);

        emitter.startFollow(player);

        // PRINCESS
        princess = this.physics.add.staticSprite(MAP_WIDTH - 220, startY, 'prenses');
        princess.setOrigin(0.5, 1);
        princess.setDisplaySize(64, 96);
        princess.refreshBody();

        // HEARTS
        hearts = this.physics.add.group();
        for (let i=0;i<14;i++){
            let x = Phaser.Math.Between(300, MAP_WIDTH - 400);
            let y = Phaser.Math.Between(100, bottomY - 200);
            const h = hearts.create(x,y,'heart');
            h.setDisplaySize(32,32);
            h.setBounceY(Phaser.Math.FloatBetween(0.4,0.8));
            h.body.setCircle(14);
        }

        // COLLIDERS & OVERLAPS
        this.physics.add.collider(player, platforms);
        this.physics.add.collider(player, moving, moveWithPlatform);
        this.physics.add.collider(hearts, platforms);
        this.physics.add.collider(hearts, moving);
        this.physics.add.overlap(player, hearts, collectHeart, null, this);
        this.physics.add.overlap(player, princess, reachPrincess, null, this);

        // UI - score
        scoreText = this.add.text(20, 20, 'Toplanan Sevgi: 0', {
            fontSize: '26px', fill:'#fff', stroke:'#000', strokeThickness:4
        }).setScrollFactor(0).setDepth(10);

        // camera follow
        this.cameras.main.startFollow(player, true, 0.08, 0.08);
        this.cameras.main.setLerp(0.08,0.08);

        // input
        cursors = this.input.keyboard.createCursorKeys();
        this.input.addPointer(2);

        // modern mobile buttons
        createMobileButtons(this);

        // final image container (hidden)
        const finalContainer = this.add.container(0,0).setDepth(999).setScrollFactor(0).setVisible(false);
        const finalImg = this.add.image(0,0,'finalScene').setOrigin(0.5).setDepth(1000);
        finalContainer.add(finalImg);
        this.registry.set('finalContainer', finalContainer);
        this.registry.set('finalImg', finalImg);

        // on resize
        this.scale.on('resize', (gameSize) => {
            bgFar.setSize(gameSize.width, gameSize.height);
            bgMid.setSize(gameSize.width, gameSize.height * 0.6);
            bgFront.setSize(gameSize.width, gameSize.height * 0.25);
            // reposition UI buttons
            positionButtons(this);
        });

    } // create end

    function update(time,delta) {
        // parallax move (based on camera)
        const camX = this.cameras.main.scrollX;
        bgFar.tilePositionX = camX * 0.12;
        bgMid.tilePositionX = camX * 0.25;
        bgFront.tilePositionX = camX * 0.45;

        // moving platforms update (children of world)
        this.physics.world.bodies.entries.forEach(b => {
            if (b.gameObject && b.gameObject.minMoveX !== undefined) {
                const go = b.gameObject;
                if (go.moveRight) {
                    go.body.setVelocityX(go.moveSpeed);
                    if (go.x > go.maxMoveX) go.moveRight=false;
                } else {
                    go.body.setVelocityX(-go.moveSpeed);
                    if (go.x < go.minMoveX) go.moveRight=true;
                }
            }
        });

        // controls
        const onGround = player.body.blocked.down || player.body.touching.down;
        let moving = false;

        if (cursors.left.isDown || isLeft) {
            player.setVelocityX(-260);
            player.setFlipX(true);
            moving = true;
        } else if (cursors.right.isDown || isRight) {
            player.setVelocityX(260);
            player.setFlipX(false);
            moving = true;
        } else {
            // small damping for snappy stop
            player.setVelocityX(player.body.velocity.x * 0.88);
            if (Math.abs(player.body.velocity.x) < 6) player.setVelocityX(0);
        }

        if ((Phaser.Input.Keyboard.JustDown(cursors.up) || isJump) && onGround) {
            player.setVelocityY(-620);
            emitter.on = false;
            // short jump press behavior: jump then reset isJump so holding doesn't trigger repeatedly
            isJump = false;
        }

        // emitter when running on ground
        emitter.on = moving && onGround;

        // if fell below screen -> restart
        if (player.y > this.scale.height + 200) {
            this.scene.restart();
            // score reset handled by collectHeart logic; reset registry if needed
            this.registry.set('score', 0);
        }
    }

    /* ---------- Helper functions ---------- */

    function createFloor(scene, group, startX, endX) {
        const width = endX - startX;
        const centerX = startX + width/2;
        const y = scene.scale.height - (GROUND_HEIGHT/2);

        const floor = group.create(centerX, y, 'ground');
        floor.setOrigin(0.5, 0.5);
        floor.setDisplaySize(width, GROUND_HEIGHT);
        floor.setTint(0x1e8b3a); // daha canlƒ± zemin
        floor.refreshBody();
    }

    function createBlock(group, x, y) {
        const b = group.create(x, y, 'ground');
        b.setOrigin(0.5, 0.5);
        b.setDisplaySize(120, 32);
        b.setTint(0x3b2f1b);
        b.refreshBody();
    }

    function setMovingData(go, minX, maxX, speed) {
        go.minMoveX = minX;
        go.maxMoveX = maxX;
        go.moveSpeed = speed;
        go.moveRight = true;
        go.body.setCollideWorldBounds(true);
    }

    function moveWithPlatform(playerObj, platform) {
        // add platform horizontal velocity to player when standing on top
        if (playerObj.body.touching.down && platform.body.touching.up) {
            playerObj.x += platform.body.velocity.x * (1/60); // gentle transfer to avoid jitter
        }
    }

    function collectHeart(playerObj, heart) {
        heart.disableBody(true,true);
        let s = this.registry.get('score') || 0;
        s += 10;
        this.registry.set('score', s);
        scoreText.setText('Toplanan Sevgi: ' + s);
    }

    function reachPrincess(playerObj, princessObj) {
        // show final screen
        const scene = playerObj.scene;
        scene.physics.pause();
        playerObj.setVisible(false);
        princessObj.setVisible(false);
        scoreText.setVisible(false);
        hideButtons();
        emitter.on = false;

        const finalContainer = scene.registry.get('finalContainer');
        const finalImg = scene.registry.get('finalImg');

        finalContainer.setVisible(true);
        finalContainer.x = scene.scale.width/2;
        finalContainer.y = scene.scale.height/2;
        finalImg.setDisplaySize(scene.scale.width, scene.scale.height);
        finalImg.setPosition(scene.scale.width/2, scene.scale.height/2);
        scene.add.text(scene.scale.width/2, 60, 'MUTLU SON ‚ù§Ô∏è', {
            fontSize: '50px', fill:'#fff', stroke:'#000', strokeThickness:8, fontFamily: 'Arial Black'
        }).setOrigin(0.5).setScrollFactor(0).setDepth(1001);
    }

    /* ---------- Mobile buttons (graphics -> texture) ---------- */
    function createMobileButtons(scene) {
        // create rounded rectangle textures (only once)
        const w = 130, h = 110, radius = 20;
        const g = scene.make.graphics({x:0,y:0,add:false});
        g.fillStyle(0x000000, 0.35);
        g.fillRoundedRect(0,0,w,h,radius);
        g.lineStyle(4, 0xffffff, 0.08);
        g.strokeRoundedRect(0,0,w,h,radius);
        g.generateTexture('btnBg', w, h);
        g.clear();

        // left
        btnLeft = scene.add.image(60, scene.scale.height - 110, 'btnBg').setScrollFactor(0).setInteractive();
        const leftArrow = scene.add.text(0,0,'‚¨ÖÔ∏è',{ fontSize:'56px' }).setOrigin(0.5).setDepth(5);
        const leftContainer = scene.add.container(btnLeft.x, btnLeft.y, [btnLeft,leftArrow]).setScrollFactor(0).setDepth(20);
        leftContainer.setSize(w,h);
        leftContainer.setInteractive(new Phaser.Geom.Rectangle(-w/2,-h/2,w,h), Phaser.Geom.Rectangle.Contains);
        leftContainer.on('pointerdown', () => isLeft = true);
        leftContainer.on('pointerup', () => isLeft = false);
        leftContainer.on('pointerout', () => isLeft = false);

        // right
        btnRight = scene.add.image(200, scene.scale.height - 110, 'btnBg').setScrollFactor(0).setInteractive();
        const rightArrow = scene.add.text(0,0,'‚û°Ô∏è',{ fontSize:'56px' }).setOrigin(0.5).setDepth(5);
        const rightContainer = scene.add.container(btnRight.x, btnRight.y, [btnRight,rightArrow]).setScrollFactor(0).setDepth(20);
        rightContainer.setSize(w,h);
        rightContainer.setInteractive(new Phaser.Geom.Rectangle(-w/2,-h/2,w,h), Phaser.Geom.Rectangle.Contains);
        rightContainer.on('pointerdown', () => isRight = true);
        rightContainer.on('pointerup', () => isRight = false);
        rightContainer.on('pointerout', () => isRight = false);

        // jump (right side)
        btnJump = scene.add.image(scene.scale.width - 110, scene.scale.height - 110, 'btnBg').setScrollFactor(0).setInteractive();
        const jumpArrow = scene.add.text(0,0,'‚è´',{ fontSize:'48px' }).setOrigin(0.5).setDepth(5);
        const jumpContainer = scene.add.container(btnJump.x, btnJump.y, [btnJump, jumpArrow]).setScrollFactor(0).setDepth(20);
        jumpContainer.setSize(w,h);
        jumpContainer.setInteractive(new Phaser.Geom.Rectangle(-w/2,-h/2,w,h), Phaser.Geom.Rectangle.Contains);
        jumpContainer.on('pointerdown', () => isJump = true);
        jumpContainer.on('pointerup', () => isJump = false);
        jumpContainer.on('pointerout', () => isJump = false);

        // store containers for reposition on resize
        scene.registry.set('uiLeft', leftContainer);
        scene.registry.set('uiRight', rightContainer);
        scene.registry.set('uiJump', jumpContainer);
    }

    function positionButtons(scene) {
        const left = scene.registry.get('uiLeft');
        const right = scene.registry.get('uiRight');
        const jump = scene.registry.get('uiJump');
        if (!left || !right || !jump) return;
        left.x = 60; left.y = scene.scale.height - 110;
        right.x = 200; right.y = scene.scale.height - 110;
        jump.x = scene.scale.width - 110; jump.y = scene.scale.height - 110;
        // reposition children
        left.list.forEach(o => o.setPosition(left.x, left.y));
        right.list.forEach(o => o.setPosition(right.x, right.y));
        jump.list.forEach(o => o.setPosition(jump.x, jump.y));
    }

    function hideButtons() {
        const s = game.scene.scenes[0];
        const left = s.registry.get('uiLeft');
        const right = s.registry.get('uiRight');
        const jump = s.registry.get('uiJump');
        if (left) left.setVisible(false);
        if (right) right.setVisible(false);
        if (jump) jump.setVisible(false);
    }

})(); // IIFE end
</script>
</body>
</html>


